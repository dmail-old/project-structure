{"version":3,"file":"index.js","sources":["../node_modules/@dmail/cancellation/src/arrayHelper.js","../node_modules/@dmail/cancellation/src/cancellation.js","../node_modules/@dmail/cancellation/src/createOperation.js","../src/pathnameMatch.js","../src/pathnameToMeta.js","../src/pathnameCanContainsMetaMatching.js","../src/selectAllFileInsideFolder.js","../src/namedValueDescriptionToMetaDescription.js"],"sourcesContent":["// TODO: externalize this into '@dmail/helper'\n// import { arrayWithout } from '@dmail/helper'\n\nexport const arrayWithout = (array, item) => {\n  const arrayWithoutItem = []\n  let i = 0\n  while (i < array.length) {\n    const value = array[i]\n    i++\n    if (value === item) {\n      continue\n    }\n    arrayWithoutItem.push(value)\n  }\n  return arrayWithoutItem\n}\n","// https://github.com/tc39/proposal-cancellation/tree/master/stage0\nimport { arrayWithout } from \"./arrayHelper.js\"\n\nexport const createCancelError = (reason) => {\n  const cancelError = new Error(`canceled because ${reason}`)\n  cancelError.name = \"CANCEL_ERROR\"\n  cancelError.reason = reason\n  return cancelError\n}\n\nexport const isCancelError = (value) => {\n  return value && typeof value === \"object\" && value.name === \"CANCEL_ERROR\"\n}\n\nexport const errorToCancelReason = (error) => {\n  if (!isCancelError(error)) return \"\"\n  return error.reason\n}\n\nexport const createCancellationSource = () => {\n  let requested = false\n  let cancelError\n  let registrationArray = []\n  const cancel = (reason) => {\n    if (requested) return\n    requested = true\n    cancelError = createCancelError(reason)\n\n    const registrationArrayCopy = registrationArray.slice()\n    registrationArray.length = 0\n    registrationArrayCopy.forEach((registration) => {\n      registration.callback(cancelError)\n      // const removedDuringCall = registrationArray.indexOf(registration) === -1\n    })\n  }\n\n  const register = (callback) => {\n    const existingRegistration = registrationArray.find((registration) => {\n      return registration.callback === callback\n    })\n    // don't register twice\n    if (existingRegistration) {\n      return existingRegistration\n    }\n\n    const registration = {\n      callback,\n      unregister: () => {\n        registrationArray = arrayWithout(registrationArray, registration)\n      },\n    }\n    registrationArray = [registration, ...registrationArray]\n\n    return registration\n  }\n\n  const throwIfRequested = () => {\n    if (requested) {\n      throw cancelError\n    }\n  }\n\n  return {\n    token: {\n      register,\n      get cancellationRequested() {\n        return requested\n      },\n      throwIfRequested,\n    },\n    cancel,\n  }\n}\n\nexport const cancellationTokenCompose = (...tokens) => {\n  const register = (callback) => {\n    const registrationArray = []\n\n    const visit = (i) => {\n      const token = tokens[i]\n      const registration = token.register(callback)\n      registrationArray.push(registration)\n    }\n    let i = 0\n    while (i < tokens.length) {\n      visit(i++)\n    }\n\n    const compositeRegistration = {\n      callback,\n      unregister: () => {\n        registrationArray.forEach((registration) => registration.unregister())\n        registrationArray.length = 0\n      },\n    }\n\n    return compositeRegistration\n  }\n\n  let requested = false\n  let cancelError\n  const internalRegistration = register((parentCancelError) => {\n    requested = true\n    cancelError = parentCancelError\n    internalRegistration.unregister()\n  })\n\n  const throwIfRequested = () => {\n    if (requested) {\n      throw cancelError\n    }\n  }\n\n  return {\n    register,\n    get cancellationRequested() {\n      return requested\n    },\n    throwIfRequested,\n  }\n}\n\nexport const createCancellationToken = () => {\n  const register = (callback) => {\n    return {\n      callback,\n      unregister: () => {},\n    }\n  }\n\n  const throwIfRequested = () => undefined\n\n  return {\n    register,\n    cancellationRequested: false,\n    throwIfRequested,\n  }\n}\n","import { createCancellationToken } from \"./cancellation.js\"\n\nexport const createOperation = ({\n  cancellationToken = createCancellationToken(),\n  start,\n  ...rest\n}) => {\n  ensureExactParameters(rest)\n  cancellationToken.throwIfRequested()\n\n  const promise = new Promise((resolve) => {\n    resolve(start())\n  })\n  const cancelPromise = new Promise((resolve, reject) => {\n    const cancelRegistration = cancellationToken.register((cancelError) => {\n      cancelRegistration.unregister()\n      reject(cancelError)\n    })\n    promise.then(cancelRegistration.unregister, () => {})\n  })\n  const operationPromise = Promise.race([promise, cancelPromise])\n\n  return operationPromise\n}\n\nconst ensureExactParameters = (extraParameters) => {\n  const extraParamNames = Object.keys(extraParameters)\n  if (extraParamNames.length)\n    throw new Error(`createOperation expect only cancellationToken, start. Got ${extraParamNames}`)\n}\n","// https://git-scm.com/docs/gitignore\n// https://github.com/kaelzhang/node-ignore\n\nexport const pathnameMatch = ({ pathname, pattern }) => {\n  return match({\n    patterns: pattern.split(\"/\"),\n    parts: pathname.split(\"/\"),\n    lastPatternRequired: false,\n    lastSkipRequired: true,\n    skipPredicate: (sequencePattern) => sequencePattern === \"**\",\n    matchPart: (sequencePattern, sequencePart) => {\n      return match({\n        patterns: sequencePattern.split(\"\"),\n        parts: sequencePart.split(\"\"),\n        lastPatternRequired: true,\n        lastSkipRequired: false,\n        skipPredicate: (charPattern) => charPattern === \"*\",\n        matchPart: (charPattern, charSource) => {\n          const matched = charPattern === charSource\n          return {\n            matched,\n            patternIndex: 0,\n            partIndex: 0,\n            matchIndex: matched ? 1 : 0,\n          }\n        },\n      })\n    },\n  })\n}\n\nconst match = ({\n  patterns,\n  parts,\n  skipPredicate,\n  lastSkipRequired,\n  lastPatternRequired,\n  matchPart,\n  skipUntilStartsMatching = false,\n}) => {\n  let matched\n  let patternIndex = 0\n  let partIndex = 0\n  let matchIndex = 0\n\n  if (patterns.length === 0 && parts.length === 0) {\n    matched = true\n  } else if (patterns.length === 0 && parts.length) {\n    matched = true\n    matchIndex = parts.length\n  } else if (patterns.length && parts.length === 0) {\n    matched = false\n  } else {\n    matched = true\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const pattern = patterns[patternIndex]\n      const part = parts[partIndex]\n      const isSkipPattern = skipPredicate(pattern)\n      const isLastPattern = patternIndex === patterns.length - 1\n      const isLastPart = partIndex === parts.length - 1\n\n      if (isSkipPattern && isLastPart && isLastPattern) {\n        matchIndex += part.length\n        break\n      }\n\n      if (isSkipPattern && isLastPattern && isLastPart === false) {\n        matchIndex += part.length\n        break\n      }\n\n      if (isSkipPattern && isLastPattern === false && isLastPart) {\n        // test next pattern on current part\n        patternIndex++\n        const nextPatternResult = match({\n          patterns: patterns.slice(patternIndex),\n          parts: parts.slice(partIndex),\n          skipPredicate,\n          lastSkipRequired,\n          lastPatternRequired,\n          matchPart,\n        })\n        matched = nextPatternResult.matched\n        patternIndex += nextPatternResult.patternIndex\n        partIndex += nextPatternResult.partIndex\n\n        if (matched && patternIndex === patterns.length - 1) {\n          matchIndex += nextPatternResult.matchIndex\n          break\n        }\n        if (matched && partIndex === parts.length - 1) {\n          matchIndex += nextPatternResult.matchIndex\n          break\n        }\n        if (matched) {\n          matchIndex += nextPatternResult.matchIndex\n          continue\n        }\n\n        // we still increase the matchIndex by the length of the part because\n        // this part has matched even if the full pattern is not satisfied\n        matchIndex += part.length\n        break\n      }\n\n      if (isSkipPattern && isLastPattern === false && isLastPart === false) {\n        // test next pattern on current part\n        patternIndex++\n\n        const skipResult = match({\n          patterns: patterns.slice(patternIndex),\n          parts: parts.slice(partIndex),\n          skipPredicate,\n          lastSkipRequired,\n          lastPatternRequired,\n          matchPart,\n          skipUntilStartsMatching: true,\n        })\n\n        matched = skipResult.matched\n        patternIndex += skipResult.patternIndex\n        partIndex += skipResult.partIndex\n        matchIndex += skipResult.matchIndex\n\n        if (matched && patternIndex === patterns.length - 1) {\n          break\n        }\n        if (matched && partIndex === parts.length - 1) {\n          break\n        }\n        if (matched) {\n          continue\n        }\n        break\n      }\n\n      const partMatch = matchPart(pattern, part)\n      matched = partMatch.matched\n      matchIndex += partMatch.matchIndex\n      if (matched === false && skipUntilStartsMatching) {\n        matchIndex += part.length\n      }\n\n      if (matched && isLastPattern && isLastPart) {\n        break\n      }\n\n      if (matched && isLastPattern && isLastPart === false) {\n        if (lastPatternRequired) {\n          matched = false\n        }\n        break\n      }\n\n      if (matched && isLastPattern === false && isLastPart) {\n        const remainingPatternAreSkip = patterns\n          .slice(patternIndex + 1)\n          .every((pattern) => skipPredicate(pattern))\n\n        if (remainingPatternAreSkip && lastSkipRequired) {\n          matched = false\n          break\n        }\n        if (remainingPatternAreSkip === false) {\n          matched = false\n          break\n        }\n        break\n      }\n\n      if (matched && isLastPattern === false && isLastPart === false) {\n        patternIndex++\n        partIndex++\n        continue\n      }\n\n      if (matched === false && skipUntilStartsMatching && isLastPart === false) {\n        partIndex++ // keep searching for that pattern\n        continue\n      }\n\n      break\n    }\n  }\n\n  return {\n    matched,\n    matchIndex,\n    patternIndex,\n    partIndex,\n  }\n}\n","import { pathnameMatch } from \"./pathnameMatch.js\"\n\nexport const pathnameToMeta = ({ pathname, metaDescription }) => {\n  return Object.keys(metaDescription).reduce((previousMeta, metaPattern) => {\n    const { matched } = pathnameMatch({ pathname, pattern: metaPattern })\n    return matched ? { ...previousMeta, ...metaDescription[metaPattern] } : previousMeta\n  }, {})\n}\n","import { pathnameMatch } from \"./pathnameMatch.js\"\nimport { pathnameToMeta } from \"./pathnameToMeta.js\"\n\nexport const pathnameCanContainsMetaMatching = ({ pathname, metaDescription, predicate }) => {\n  if (typeof pathname !== \"string\")\n    throw new TypeError(`pathname must be a string, got ${pathname}`)\n  if (typeof metaDescription !== \"object\")\n    throw new TypeError(`metaDescription must be an object, got ${metaDescription}`)\n  if (typeof predicate !== \"function\")\n    throw new TypeError(`predicate must be a function, got ${predicate}`)\n\n  const matchIndexForFolder = pathname.split(\"/\").join(\"\").length\n  const partialMatch = Object.keys(metaDescription).some((pattern) => {\n    const { matched, matchIndex } = pathnameMatch({\n      pathname,\n      pattern,\n    })\n    return (\n      matched === false && matchIndex >= matchIndexForFolder && predicate(metaDescription[pattern])\n    )\n  })\n  if (partialMatch) return true\n\n  // no partial match satisfies predicate, does it work on a full match ?\n  const meta = pathnameToMeta({ pathname, metaDescription })\n  return Boolean(predicate(meta))\n}\n","import fs from \"fs\"\nimport { createCancellationToken, createOperation } from \"@dmail/cancellation\"\nimport { pathnameCanContainsMetaMatching } from \"./pathnameCanContainsMetaMatching.js\"\nimport { pathnameToMeta } from \"./pathnameToMeta.js\"\n\n// when using node 10.0 consider to convert this to async generator ?\nexport const selectAllFileInsideFolder = async ({\n  cancellationToken = createCancellationToken(),\n  pathname: entryPathname,\n  metaDescription,\n  predicate,\n  transformFile = (file) => file,\n}) => {\n  if (typeof entryPathname !== \"string\")\n    throw new TypeError(`pathname must be a string, got ${entryPathname}`)\n  if (typeof metaDescription !== \"object\")\n    throw new TypeError(`metaMap must be a object, got ${metaDescription}`)\n  if (typeof predicate !== \"function\")\n    throw new TypeError(`predicate must be a function, got ${predicate}`)\n  if (typeof transformFile !== \"function\")\n    throw new TypeError(`transformFile must be a function, got ${transformFile}`)\n\n  const results = []\n\n  const visitFolder = async (folderPathname) => {\n    const names = await createOperation({\n      cancellationToken,\n      start: () => readDirectory(folderPathname),\n    })\n\n    await Promise.all(\n      names.map(async (name) => {\n        const pathname = `${folderPathname}/${name}`\n        const pathnameRelative = pathnameToRelativePathname(pathname, entryPathname)\n        const lstat = await createOperation({\n          cancellationToken,\n          start: () => readLStat(pathname),\n        })\n\n        if (lstat.isDirectory()) {\n          if (\n            !pathnameCanContainsMetaMatching({\n              pathname: pathnameRelative,\n              metaDescription,\n              predicate,\n            })\n          )\n            return null\n\n          return visitFolder(pathname)\n        }\n\n        if (lstat.isFile()) {\n          const meta = pathnameToMeta({ pathname: pathnameRelative, metaDescription })\n          if (!predicate(meta)) {\n            return null\n          }\n\n          const result = await createOperation({\n            cancellationToken,\n            start: () => transformFile({ filenameRelative: pathnameRelative, meta, lstat }),\n          })\n          results.push(result)\n          return null\n        }\n\n        // we ignore symlink because entryFolder is recursively traversed\n        // so symlinked file will be discovered.\n        // Moreover if they lead outside of entryFolder it can become a problem\n        // like infinite recursion of whatever.\n        // that we could handle using an object of pathname already seen but it will be useless\n        // because entryFolder is recursively traversed\n\n        return null\n      }),\n    )\n  }\n  await visitFolder(entryPathname)\n\n  return results\n}\n\nconst pathnameToRelativePathname = (pathname, parentPathname) => {\n  return pathname.slice(parentPathname.length + 1)\n}\n\nconst readDirectory = (pathname) =>\n  new Promise((resolve, reject) => {\n    fs.readdir(pathname, (error, names) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve(names)\n      }\n    })\n  })\n\nconst readLStat = (pathname) =>\n  new Promise((resolve, reject) => {\n    fs.lstat(pathname, (error, stat) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve(stat)\n      }\n    })\n  })\n","export const namedValueDescriptionToMetaDescription = (namedValueDescription) => {\n  const metaDescription = {}\n\n  Object.keys(namedValueDescription).forEach((name) => {\n    const valueDescription = namedValueDescription[name]\n    Object.keys(valueDescription).forEach((pattern) => {\n      const value = valueDescription[pattern]\n      const meta = { [name]: value }\n\n      metaDescription[pattern] =\n        pattern in metaDescription ? { ...metaDescription[pattern], ...meta } : meta\n    })\n  })\n\n  return metaDescription\n}\n"],"names":["ensureExactParameters","pathnameMatch","pathname","pattern","match","patterns","split","parts","lastPatternRequired","lastSkipRequired","skipPredicate","sequencePattern","matchPart","sequencePart","charPattern","charSource","matched","patternIndex","partIndex","matchIndex","skipUntilStartsMatching","length","part","isSkipPattern","isLastPattern","isLastPart","nextPatternResult","slice","skipResult","partMatch","remainingPatternAreSkip","every","pathnameToMeta","metaDescription","Object","keys","reduce","previousMeta","metaPattern","pathnameCanContainsMetaMatching","predicate","TypeError","matchIndexForFolder","join","partialMatch","some","meta","Boolean","selectAllFileInsideFolder","cancellationToken","createCancellationToken","entryPathname","transformFile","file","results","visitFolder","folderPathname","names","createOperation","start","readDirectory","Promise","all","map","name","pathnameRelative","pathnameToRelativePathname","lstat","readLStat","isDirectory","isFile","result","filenameRelative","push","parentPathname","resolve","reject","fs","readdir","error","stat","namedValueDescriptionToMetaDescription","namedValueDescription","forEach","valueDescription","value"],"mappings":"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"}