{"version":3,"file":"index.js","sources":["../src/configToMetaMap.js","../src/ressourceMatch.js","../src/ressourceToMeta.js","../src/ressourceCanContainsMetaMatching.js","../src/forEachRessourceMatching.js","../src/readProjectMetaMap.js"],"sourcesContent":["export const configToMetaMap = (config) => {\n  const metas = config.metas || {}\n  const metaMap = {}\n\n  Object.keys(metas).forEach((metaName) => {\n    const metaPatterns = metas[metaName]\n    Object.keys(metaPatterns).forEach((pattern) => {\n      const metaValue = metaPatterns[pattern]\n      const meta = { [metaName]: metaValue }\n\n      metaMap[pattern] = pattern in metaMap ? { ...metaMap[pattern], ...meta } : meta\n    })\n  })\n\n  return metaMap\n}\n","// https://git-scm.com/docs/gitignore\n\nconst match = ({\n  patterns,\n  parts,\n  skipPredicate,\n  lastSkipRequired,\n  lastPatternRequired,\n  matchPart,\n  skipUntilStartsMatching = false,\n}) => {\n  let matched\n  let patternIndex = 0\n  let partIndex = 0\n  let matchIndex = 0\n\n  if (patterns.length === 0 && parts.length === 0) {\n    matched = true\n  } else if (patterns.length === 0 && parts.length) {\n    matched = true\n    matchIndex = parts.length\n  } else if (patterns.length && parts.length === 0) {\n    matched = false\n  } else {\n    matched = true\n\n    while (true) {\n      const pattern = patterns[patternIndex]\n      const part = parts[partIndex]\n      const isSkipPattern = skipPredicate(pattern)\n      const isLastPattern = patternIndex === patterns.length - 1\n      const isLastPart = partIndex === parts.length - 1\n\n      if (isSkipPattern && isLastPart && isLastPattern) {\n        matchIndex += part.length\n        break\n      }\n\n      if (isSkipPattern && isLastPattern && isLastPart === false) {\n        matchIndex += part.length\n        break\n      }\n\n      if (isSkipPattern && isLastPattern === false && isLastPart) {\n        // test next pattern on current part\n        patternIndex++\n        const nextPatternResult = match({\n          patterns: patterns.slice(patternIndex),\n          parts: parts.slice(partIndex),\n          skipPredicate,\n          lastSkipRequired,\n          lastPatternRequired,\n          matchPart,\n        })\n        matched = nextPatternResult.matched\n        patternIndex += nextPatternResult.patternIndex\n        partIndex += nextPatternResult.partIndex\n\n        if (matched && patternIndex === patterns.length - 1) {\n          matchIndex += nextPatternResult.matchIndex\n          break\n        }\n        if (matched && partIndex === parts.length - 1) {\n          matchIndex += nextPatternResult.matchIndex\n          break\n        }\n        if (matched) {\n          matchIndex += nextPatternResult.matchIndex\n          continue\n        }\n\n        // we still increase the matchIndex by the length of the part because\n        // this part has matched even if the full pattern is not satisfied\n        matchIndex += part.length\n        break\n      }\n\n      if (isSkipPattern && isLastPattern === false && isLastPart === false) {\n        // test next pattern on current part\n        patternIndex++\n\n        const skipResult = match({\n          patterns: patterns.slice(patternIndex),\n          parts: parts.slice(partIndex),\n          skipPredicate,\n          lastSkipRequired,\n          lastPatternRequired,\n          matchPart,\n          skipUntilStartsMatching: true,\n        })\n\n        matched = skipResult.matched\n        patternIndex += skipResult.patternIndex\n        partIndex += skipResult.partIndex\n        matchIndex += skipResult.matchIndex\n\n        if (matched && patternIndex === patterns.length - 1) {\n          break\n        }\n        if (matched && partIndex === parts.length - 1) {\n          break\n        }\n        if (matched) {\n          continue\n        }\n        break\n      }\n\n      const partMatch = matchPart(pattern, part)\n      matched = partMatch.matched\n      matchIndex += partMatch.matchIndex\n      if (matched === false && skipUntilStartsMatching) {\n        matchIndex += part.length\n      }\n\n      if (matched && isLastPattern && isLastPart) {\n        break\n      }\n\n      if (matched && isLastPattern && isLastPart === false) {\n        if (lastPatternRequired) {\n          matched = false\n        }\n        break\n      }\n\n      if (matched && isLastPattern === false && isLastPart) {\n        const remainingPatternAreSkip = patterns\n          .slice(patternIndex + 1)\n          .every((pattern) => skipPredicate(pattern))\n\n        if (remainingPatternAreSkip && lastSkipRequired) {\n          matched = false\n          break\n        }\n        if (remainingPatternAreSkip === false) {\n          matched = false\n          break\n        }\n        break\n      }\n\n      if (matched && isLastPattern === false && isLastPart === false) {\n        patternIndex++\n        partIndex++\n        continue\n      }\n\n      if (matched === false && skipUntilStartsMatching && isLastPart === false) {\n        partIndex++ // keep searching for that pattern\n        continue\n      }\n\n      break\n    }\n  }\n\n  return {\n    matched,\n    matchIndex,\n    patternIndex,\n    partIndex,\n  }\n}\n\nexport const ressourceMatch = (pattern, ressource) => {\n  return match({\n    patterns: pattern.split(\"/\"),\n    parts: ressource.split(\"/\"),\n    lastPatternRequired: false,\n    lastSkipRequired: true,\n    skipPredicate: (sequencePattern) => sequencePattern === \"**\",\n    matchPart: (sequencePattern, sequencePart) => {\n      return match({\n        patterns: sequencePattern.split(\"\"),\n        parts: sequencePart.split(\"\"),\n        lastPatternRequired: true,\n        lastSkipRequired: false,\n        skipPredicate: (charPattern) => charPattern === \"*\",\n        matchPart: (charPattern, charSource) => {\n          const matched = charPattern === charSource\n          return {\n            matched,\n            patternIndex: 0,\n            partIndex: 0,\n            matchIndex: matched ? 1 : 0,\n          }\n        },\n      })\n    },\n  })\n}\n","import { ressourceMatch } from \"./ressourceMatch.js\"\n\nexport const ressourceToMeta = (metaMap, ressource) => {\n  return Object.keys(metaMap).reduce((previousMeta, pattern) => {\n    const { matched } = ressourceMatch(pattern, ressource)\n    return matched ? { ...previousMeta, ...metaMap[pattern] } : previousMeta\n  }, {})\n}\n","import { ressourceMatch } from \"./ressourceMatch.js\"\nimport { ressourceToMeta } from \"./ressourceToMeta.js\"\n\nexport const ressourceCanContainsMetaMatching = (metaMap, ressource, predicate) => {\n  if (typeof metaMap !== \"object\") {\n    throw new TypeError(\n      `ressourceCanContainsMetaMatching metaMap must be an object, got ${metaMap}`,\n    )\n  }\n  if (typeof ressource !== \"string\") {\n    throw new TypeError(\n      `ressourceCanContainsMetaMatching ressource must be a string, got ${ressource}`,\n    )\n  }\n  if (typeof predicate !== \"function\") {\n    throw new TypeError(\n      `ressourceCanContainsMetaMatching predicate must be a function, got ${predicate}`,\n    )\n  }\n\n  const matchIndexForRessource = ressource.split(\"/\").join(\"\").length\n  const partialMatch = Object.keys(metaMap).some((pattern) => {\n    const { matched, matchIndex } = ressourceMatch(pattern, ressource)\n    return matched === false && matchIndex >= matchIndexForRessource && predicate(metaMap[pattern])\n  })\n  if (partialMatch) {\n    return true\n  }\n\n  // no partial match satisfies predicate, does it work on a full match ?\n  const meta = ressourceToMeta(metaMap, ressource)\n  return Boolean(predicate(meta))\n}\n","import fs from \"fs\"\nimport { ressourceCanContainsMetaMatching } from \"./ressourceCanContainsMetaMatching.js\"\nimport { ressourceToMeta } from \"./ressourceToMeta.js\"\n\nconst readDirectory = (dirname) =>\n  new Promise((resolve, reject) => {\n    fs.readdir(dirname, (error, names) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve(names)\n      }\n    })\n  })\n\nconst readStat = (filename) =>\n  new Promise((resolve, reject) => {\n    fs.stat(filename, (error, stat) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve(stat)\n      }\n    })\n  })\n\nconst nothingToDo = {}\n\nexport const forEachRessourceMatching = async (root, metaMap, predicate, callback) => {\n  if (typeof root !== \"string\") {\n    throw new TypeError(`forEachRessourceMatching metaMap must be a string, got ${root}`)\n  }\n  if (typeof metaMap !== \"object\") {\n    throw new TypeError(`forEachRessourceMatching ressource must be a object, got ${metaMap}`)\n  }\n  if (typeof predicate !== \"function\") {\n    throw new TypeError(`forEachRessourceMatching predicate must be a function, got ${predicate}`)\n  }\n  if (typeof callback !== \"function\") {\n    throw new TypeError(`forEachRessourceMatching callback must be a function, got ${callback}`)\n  }\n\n  const visitFolder = async (folder) => {\n    const folderAbsolute = folder ? `${root}/${folder}` : root\n\n    const names = await readDirectory(folderAbsolute)\n\n    const results = await Promise.all(\n      names.map(async (name) => {\n        const ressource = folder ? `${folder}/${name}` : name\n\n        const ressourceAbsolute = `${root}/${ressource}`\n        const stat = await readStat(ressourceAbsolute)\n\n        if (stat.isDirectory()) {\n          if (!ressourceCanContainsMetaMatching(metaMap, ressource, predicate)) {\n            return [nothingToDo]\n          }\n          return visitFolder(ressource)\n        }\n\n        const meta = ressourceToMeta(metaMap, ressource)\n        if (!predicate(meta)) {\n          return [nothingToDo]\n        }\n\n        const result = await callback(ressource, meta)\n        return [result]\n      }),\n    )\n\n    return results.reduce((previous, results) => {\n      return [...previous, ...results]\n    }, [])\n  }\n\n  const allResults = await visitFolder()\n  return allResults.filter((result) => result !== nothingToDo)\n}\n","import { configToMetaMap } from \"./configToMetaMap.js\"\n\nconst CONFIG_FILE_NAME = \"structure.config.js\"\n\nconst loadConfigFile = (filename) => {\n  return new Promise((resolve, reject) => {\n    let value\n    let errored = false\n    try {\n      // eslint-disable-nextline no-dynamic-require\n      value = require(filename)\n    } catch (e) {\n      value = e\n      errored = true\n    }\n\n    if (errored) {\n      const error = value\n      if (error && error.code === \"MODULE_NOT_FOUND\") {\n        return reject(new Error(`${filename} not found`))\n      }\n      if (error && error.code === \"SYNTAX_ERROR\") {\n        console.error(`${filename} contains a syntax error`)\n        return reject(error)\n      }\n      if (error && error.code === \"REFERENCE_ERROR\") {\n        console.error(`${filename} contains a reference error`)\n        return reject(error)\n      }\n      return reject(error)\n    }\n\n    const namespace = value\n    const namespaceType = typeof namespace\n    if (namespaceType !== \"object\") {\n      return reject(new TypeError(`${filename} must export an object, got ${namespaceType}`))\n    }\n\n    resolve(namespace || {})\n  })\n}\n\nexport const readProjectMetaMap = ({ root, config = CONFIG_FILE_NAME }) => {\n  return loadConfigFile(`${root}/${config}`).then((config) => {\n    return configToMetaMap(config)\n  })\n}\n"],"names":["configToMetaMap","config","metas","metaMap","Object","keys","forEach","metaName","metaPatterns","pattern","metaValue","meta","match","patterns","parts","skipPredicate","lastSkipRequired","lastPatternRequired","matchPart","skipUntilStartsMatching","matched","patternIndex","partIndex","matchIndex","length","part","isSkipPattern","isLastPattern","isLastPart","nextPatternResult","slice","skipResult","partMatch","remainingPatternAreSkip","every","ressourceMatch","ressource","split","sequencePattern","sequencePart","charPattern","charSource","ressourceToMeta","reduce","previousMeta","ressourceCanContainsMetaMatching","predicate","TypeError","matchIndexForRessource","join","partialMatch","some","Boolean","readDirectory","dirname","Promise","resolve","reject","fs","readdir","error","names","readStat","filename","stat","nothingToDo","forEachRessourceMatching","root","callback","visitFolder","folder","folderAbsolute","results","all","map","name","ressourceAbsolute","isDirectory","result","previous","allResults","filter","CONFIG_FILE_NAME","loadConfigFile","value","errored","require","e","code","Error","console","namespace","namespaceType","readProjectMetaMap","then"],"mappings":"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"}