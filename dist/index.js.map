{"version":3,"file":"index.js","sources":["../src/pathnameMatch.js","../node_modules/@dmail/cancellation/src/arrayHelper.js","../node_modules/@dmail/cancellation/src/cancellation.js","../node_modules/@dmail/cancellation/src/createOperation.js","../src/pathnameCanContainsMetaMatching.js","../src/pathnameToMeta.js","../src/selectAllFileInsideFolder.js","../src/namedValueDescriptionToMetaDescription.js"],"sourcesContent":["// https://git-scm.com/docs/gitignore\n// https://github.com/kaelzhang/node-ignore\n\n/*\n{\n  matched: Boolean, // true false if value match\n  highestMatchingIndex: Number, // the index at which we were able to determine value matched or not\n}\n*/\n\nexport const pathnameMatch = ({ pattern, pathname }) => {\n  if (typeof pattern !== \"string\")\n    throw new TypeError(`pattern must be a string.\npattern: ${pattern}`)\n  if (pattern[0] !== \"/\")\n    throw new Error(`pattern must start with /.\npattern: ${pattern}`)\n\n  if (typeof pathname !== \"string\")\n    throw new TypeError(`pathname must be a string.\npathname: ${pathname}`)\n  if (pathname[0] !== \"/\")\n    throw new Error(`pathname must start with /.\npathname: ${pathname}`)\n\n  return match({ pattern, pathname })\n}\n\nconst match = ({ pattern, pathname }) => {\n  let patternIndex = 0\n  let pathnameIndex = 0\n  let remainingPattern = pattern\n  let remainingPathname = pathname\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    //  '' === '' -> pass\n    if (remainingPattern === \"\" && remainingPathname === \"\") {\n      return pass({\n        patternIndex,\n        pathnameIndex,\n      })\n    }\n\n    // '' === value -> fail\n    if (remainingPattern === \"\" && remainingPathname !== \"\") {\n      return fail({\n        patternIndex,\n        pathnameIndex,\n      })\n    }\n\n    // pattern === '' -> pass only if pattern is only **\n    if (remainingPattern !== \"\" && remainingPathname === \"\") {\n      // pass because pattern is optionnal\n      if (remainingPattern === \"**\") {\n        return pass({\n          patternIndex,\n          pathnameIndex,\n        })\n      }\n\n      // fail because **/ would expect something like /a\n      // and **a would expect something like foo/bar/a\n      return fail({\n        patternIndex,\n        pathnameIndex,\n      })\n    }\n\n    if (remainingPattern.slice(0, \"**\".length) === \"**\") {\n      patternIndex += `**`.length\n      remainingPattern = remainingPattern.slice(`**`.length)\n      if (remainingPattern[0] === \"/\") {\n        patternIndex += \"/\".length\n        remainingPattern = remainingPattern.slice(\"/\".length)\n      }\n\n      // pattern ending with ** always match remaining pathname\n      if (remainingPattern === \"\") {\n        return pass({\n          patternIndex,\n          pathnameIndex: pathname.length,\n        })\n      }\n\n      const skipResult = skipUntilMatch({ pattern: remainingPattern, pathname: remainingPathname })\n\n      if (!skipResult.matched) {\n        return fail({\n          patternIndex: patternIndex + skipResult.patternIndex,\n          pathnameIndex: pathnameIndex + skipResult.pathnameIndex,\n        })\n      }\n\n      return pass({\n        patternIndex: pattern.length,\n        pathnameIndex: pathname.length,\n      })\n    }\n\n    if (remainingPattern[0] === \"*\") {\n      patternIndex += \"*\".length\n      remainingPattern = remainingPattern.slice(\"*\".length)\n\n      // la c'est plus délicat, il faut que remainingPathname\n      // ne soit composé que de truc !== '/'\n      if (remainingPattern === \"\") {\n        const slashIndex = remainingPathname.indexOf(\"/\")\n        if (slashIndex > -1) {\n          return fail({\n            patternIndex,\n            pathnameIndex: pathnameIndex + slashIndex,\n          })\n        }\n        return pass({\n          patternIndex,\n          pathnameIndex: pathname.length,\n        })\n      }\n\n      // the next char must not the one expected by remainingPattern[0]\n      // because * is greedy and expect to skip one char\n      if (remainingPattern[0] === remainingPathname[0]) {\n        return fail({\n          patternIndex: patternIndex - \"*\".length,\n          pathnameIndex,\n        })\n      }\n\n      const skipResult = skipUntilMatch({\n        pattern: remainingPattern,\n        pathname: remainingPathname,\n        skippablePredicate: (remainingPathname) => remainingPathname[0] !== \"/\",\n      })\n\n      if (!skipResult.matched) {\n        return fail({\n          patternIndex: patternIndex + skipResult.patternIndex,\n          pathnameIndex: pathnameIndex + skipResult.pathnameIndex,\n        })\n      }\n\n      return pass({\n        patternIndex: pattern.length,\n        pathnameIndex: pathname.length,\n      })\n    }\n\n    if (remainingPattern[0] !== remainingPathname[0]) {\n      return fail({\n        patternIndex,\n        pathnameIndex,\n      })\n    }\n\n    // trailing slash on pattern, -> match remaining\n    if (remainingPattern === \"/\" && remainingPathname.length > 1) {\n      return pass({\n        patternIndex: patternIndex + 1,\n        pathnameIndex: pathname.length,\n      })\n    }\n\n    patternIndex += 1\n    pathnameIndex += 1\n    remainingPattern = remainingPattern.slice(1)\n    remainingPathname = remainingPathname.slice(1)\n    continue\n  }\n}\n\nconst skipUntilMatch = ({ pattern, pathname, skippablePredicate = () => true }) => {\n  let pathnameIndex = 0\n  let remainingPathname = pathname\n  let bestMatch = null\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const matchAttempt = match({\n      pattern,\n      pathname: remainingPathname,\n    })\n\n    if (matchAttempt.matched) {\n      bestMatch = matchAttempt\n      break\n    }\n\n    const skippable = skippablePredicate(remainingPathname)\n\n    bestMatch = fail({\n      patternIndex: bestMatch\n        ? Math.max(bestMatch.patternIndex, matchAttempt.patternIndex)\n        : matchAttempt.patternIndex,\n      pathnameIndex: pathnameIndex + matchAttempt.pathnameIndex,\n    })\n\n    if (!skippable) {\n      break\n    }\n\n    // search against the next unattempted pathname\n    pathnameIndex += matchAttempt.pathnameIndex + 1\n    remainingPathname = remainingPathname.slice(matchAttempt.pathnameIndex + 1)\n    if (remainingPathname === \"\") {\n      bestMatch = {\n        ...bestMatch,\n        pathnameIndex: pathname.length,\n      }\n      break\n    }\n\n    continue\n  }\n\n  return bestMatch\n}\n\nconst pass = ({ patternIndex, pathnameIndex }) => {\n  return {\n    matched: true,\n    patternIndex,\n    pathnameIndex,\n  }\n}\n\nconst fail = ({ patternIndex, pathnameIndex }) => {\n  return {\n    matched: false,\n    patternIndex,\n    pathnameIndex,\n  }\n}\n","// TODO: externalize this into '@dmail/helper'\n// import { arrayWithout } from '@dmail/helper'\n\nexport const arrayWithout = (array, item) => {\n  const arrayWithoutItem = []\n  let i = 0\n  while (i < array.length) {\n    const value = array[i]\n    i++\n    if (value === item) {\n      continue\n    }\n    arrayWithoutItem.push(value)\n  }\n  return arrayWithoutItem\n}\n","// https://github.com/tc39/proposal-cancellation/tree/master/stage0\nimport { arrayWithout } from \"./arrayHelper.js\"\n\nexport const createCancelError = (reason) => {\n  const cancelError = new Error(`canceled because ${reason}`)\n  cancelError.name = \"CANCEL_ERROR\"\n  cancelError.reason = reason\n  return cancelError\n}\n\nexport const isCancelError = (value) => {\n  return value && typeof value === \"object\" && value.name === \"CANCEL_ERROR\"\n}\n\nexport const errorToCancelReason = (error) => {\n  if (!isCancelError(error)) return \"\"\n  return error.reason\n}\n\nexport const createCancellationSource = () => {\n  let requested = false\n  let cancelError\n  let registrationArray = []\n  const cancel = (reason) => {\n    if (requested) return\n    requested = true\n    cancelError = createCancelError(reason)\n\n    const registrationArrayCopy = registrationArray.slice()\n    registrationArray.length = 0\n    registrationArrayCopy.forEach((registration) => {\n      registration.callback(cancelError)\n      // const removedDuringCall = registrationArray.indexOf(registration) === -1\n    })\n  }\n\n  const register = (callback) => {\n    const existingRegistration = registrationArray.find((registration) => {\n      return registration.callback === callback\n    })\n    // don't register twice\n    if (existingRegistration) {\n      return existingRegistration\n    }\n\n    const registration = {\n      callback,\n      unregister: () => {\n        registrationArray = arrayWithout(registrationArray, registration)\n      },\n    }\n    registrationArray = [registration, ...registrationArray]\n\n    return registration\n  }\n\n  const throwIfRequested = () => {\n    if (requested) {\n      throw cancelError\n    }\n  }\n\n  return {\n    token: {\n      register,\n      get cancellationRequested() {\n        return requested\n      },\n      throwIfRequested,\n    },\n    cancel,\n  }\n}\n\nexport const cancellationTokenCompose = (...tokens) => {\n  const register = (callback) => {\n    const registrationArray = []\n\n    const visit = (i) => {\n      const token = tokens[i]\n      const registration = token.register(callback)\n      registrationArray.push(registration)\n    }\n    let i = 0\n    while (i < tokens.length) {\n      visit(i++)\n    }\n\n    const compositeRegistration = {\n      callback,\n      unregister: () => {\n        registrationArray.forEach((registration) => registration.unregister())\n        registrationArray.length = 0\n      },\n    }\n\n    return compositeRegistration\n  }\n\n  let requested = false\n  let cancelError\n  const internalRegistration = register((parentCancelError) => {\n    requested = true\n    cancelError = parentCancelError\n    internalRegistration.unregister()\n  })\n\n  const throwIfRequested = () => {\n    if (requested) {\n      throw cancelError\n    }\n  }\n\n  return {\n    register,\n    get cancellationRequested() {\n      return requested\n    },\n    throwIfRequested,\n  }\n}\n\nexport const createCancellationToken = () => {\n  const register = (callback) => {\n    return {\n      callback,\n      unregister: () => {},\n    }\n  }\n\n  const throwIfRequested = () => undefined\n\n  return {\n    register,\n    cancellationRequested: false,\n    throwIfRequested,\n  }\n}\n","import { createCancellationToken } from \"./cancellation.js\"\n\nexport const createOperation = ({\n  cancellationToken = createCancellationToken(),\n  start,\n  ...rest\n}) => {\n  ensureExactParameters(rest)\n  cancellationToken.throwIfRequested()\n\n  const promise = new Promise((resolve) => {\n    resolve(start())\n  })\n  const cancelPromise = new Promise((resolve, reject) => {\n    const cancelRegistration = cancellationToken.register((cancelError) => {\n      cancelRegistration.unregister()\n      reject(cancelError)\n    })\n    promise.then(cancelRegistration.unregister, () => {})\n  })\n  const operationPromise = Promise.race([promise, cancelPromise])\n\n  return operationPromise\n}\n\nconst ensureExactParameters = (extraParameters) => {\n  const extraParamNames = Object.keys(extraParameters)\n  if (extraParamNames.length)\n    throw new Error(`createOperation expect only cancellationToken, start. Got ${extraParamNames}`)\n}\n","import { pathnameMatch } from \"./pathnameMatch.js\"\n\nexport const pathnameCanContainsMetaMatching = ({ pathname, metaDescription, predicate }) => {\n  if (typeof pathname !== \"string\")\n    throw new TypeError(`pathname must be a string, got ${pathname}`)\n  if (typeof metaDescription !== \"object\")\n    throw new TypeError(`metaDescription must be an object, got ${metaDescription}`)\n  if (typeof predicate !== \"function\")\n    throw new TypeError(`predicate must be a function, got ${predicate}`)\n\n  // we add a trailing slash because we are intested into what will be inside\n  // this pathname, not the pathname itself\n  // it allows to match pattern for what is inside that pathname\n  const pathnameWithTrailingSlash = `${pathname}/`\n\n  // for full match we must create an object to allow pattern to override previous ones\n  let fullMatchMeta = {}\n  let someFullMatch = false\n  // for partial match, any meta satisfying predicate will be valid because\n  // we don't know for sure if pattern will still match for a file inside pathname\n  const partialMatchMetaArray = []\n\n  Object.keys(metaDescription).forEach((pattern) => {\n    const { matched, pathnameIndex } = pathnameMatch({\n      pathname: pathnameWithTrailingSlash,\n      pattern,\n    })\n    if (matched) {\n      someFullMatch = true\n      fullMatchMeta = {\n        ...fullMatchMeta,\n        ...metaDescription[pattern],\n      }\n    } else if (someFullMatch === false && pathnameIndex >= pathname.length) {\n      partialMatchMetaArray.push(metaDescription[pattern])\n    }\n  })\n\n  if (someFullMatch) return Boolean(predicate(fullMatchMeta))\n\n  return partialMatchMetaArray.some((partialMatchMeta) => predicate(partialMatchMeta))\n}\n","import { pathnameMatch } from \"./pathnameMatch.js\"\n\nexport const pathnameToMeta = ({ pathname, metaDescription }) => {\n  return Object.keys(metaDescription).reduce((previousMeta, metaPattern) => {\n    const { matched } = pathnameMatch({ pathname, pattern: metaPattern })\n    return matched ? { ...previousMeta, ...metaDescription[metaPattern] } : previousMeta\n  }, {})\n}\n","import fs from \"fs\"\nimport { createCancellationToken, createOperation } from \"@dmail/cancellation\"\nimport { pathnameCanContainsMetaMatching } from \"./pathnameCanContainsMetaMatching.js\"\nimport { pathnameToMeta } from \"./pathnameToMeta.js\"\n\n// when using node 10.0 consider to convert this to async generator ?\nexport const selectAllFileInsideFolder = async ({\n  cancellationToken = createCancellationToken(),\n  pathname: rootFolderPathname,\n  metaDescription,\n  predicate,\n  transformFile = (file) => file,\n}) => {\n  if (typeof rootFolderPathname !== \"string\")\n    throw new TypeError(`pathname must be a string, got ${rootFolderPathname}`)\n  if (typeof metaDescription !== \"object\")\n    throw new TypeError(`metaMap must be a object, got ${metaDescription}`)\n  if (typeof predicate !== \"function\")\n    throw new TypeError(`predicate must be a function, got ${predicate}`)\n  if (typeof transformFile !== \"function\")\n    throw new TypeError(`transformFile must be a function, got ${transformFile}`)\n\n  const results = []\n\n  const visitFolder = async (folder) => {\n    const folderBasenameArray = await createOperation({\n      cancellationToken,\n      start: () => readDirectory(folder),\n    })\n\n    await Promise.all(\n      folderBasenameArray.map(async (basename) => {\n        const pathname = `${folder}/${basename}`\n        const pathnameRelative = pathnameToRelativePathname(pathname, rootFolderPathname)\n        const lstat = await createOperation({\n          cancellationToken,\n          start: () => readLStat(pathname),\n        })\n\n        if (lstat.isDirectory()) {\n          if (\n            !pathnameCanContainsMetaMatching({\n              pathname: pathnameRelative,\n              metaDescription,\n              predicate,\n            })\n          )\n            return null\n\n          return visitFolder(pathname)\n        }\n\n        if (lstat.isFile()) {\n          const meta = pathnameToMeta({ pathname: pathnameRelative, metaDescription })\n          if (!predicate(meta)) {\n            return null\n          }\n\n          const result = await createOperation({\n            cancellationToken,\n            start: () =>\n              transformFile({ filenameRelative: pathnameRelative.slice(1), meta, lstat }),\n          })\n          results.push(result)\n          return null\n        }\n\n        // we ignore symlink because entryFolder is recursively traversed\n        // so symlinked file will be discovered.\n        // Moreover if they lead outside of entryFolder it can become a problem\n        // like infinite recursion of whatever.\n        // that we could handle using an object of pathname already seen but it will be useless\n        // because entryFolder is recursively traversed\n\n        return null\n      }),\n    )\n  }\n  await visitFolder(rootFolderPathname)\n\n  return results\n}\n\nconst pathnameToRelativePathname = (pathname, parentPathname) => {\n  return pathname.slice(parentPathname.length)\n}\n\nconst readDirectory = (pathname) =>\n  new Promise((resolve, reject) => {\n    fs.readdir(pathname, (error, names) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve(names)\n      }\n    })\n  })\n\nconst readLStat = (pathname) =>\n  new Promise((resolve, reject) => {\n    fs.lstat(pathname, (error, stat) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve(stat)\n      }\n    })\n  })\n","export const namedValueDescriptionToMetaDescription = (namedValueDescription) => {\n  const metaDescription = {}\n\n  Object.keys(namedValueDescription).forEach((name) => {\n    const valueDescription = namedValueDescription[name]\n    Object.keys(valueDescription).forEach((pattern) => {\n      const value = valueDescription[pattern]\n      const meta = { [name]: value }\n\n      metaDescription[pattern] =\n        pattern in metaDescription ? { ...metaDescription[pattern], ...meta } : meta\n    })\n  })\n\n  return metaDescription\n}\n"],"names":["pathnameMatch","pattern","pathname","TypeError","Error","match","patternIndex","pathnameIndex","remainingPattern","remainingPathname","pass","fail","slice","length","skipResult","skipUntilMatch","matched","slashIndex","indexOf","skippablePredicate","bestMatch","matchAttempt","skippable","Math","max","ensureExactParameters","pathnameCanContainsMetaMatching","metaDescription","predicate","pathnameWithTrailingSlash","fullMatchMeta","someFullMatch","partialMatchMetaArray","Object","keys","forEach","push","Boolean","some","partialMatchMeta","pathnameToMeta","reduce","previousMeta","metaPattern","selectAllFileInsideFolder","cancellationToken","createCancellationToken","rootFolderPathname","transformFile","file","results","visitFolder","folder","folderBasenameArray","createOperation","start","readDirectory","Promise","all","map","basename","pathnameRelative","pathnameToRelativePathname","lstat","readLStat","isDirectory","isFile","meta","result","filenameRelative","parentPathname","resolve","reject","fs","readdir","error","names","stat","namedValueDescriptionToMetaDescription","namedValueDescription","name","valueDescription","value"],"mappings":"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"}