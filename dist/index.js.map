{"version":3,"file":"index.js","sources":["../src/createLocationMeta.js","../src/forEachFileMatching.js","../src/createRoot.js"],"sourcesContent":["// https://git-scm.com/docs/gitignore\n\nconst match = ({\n  patterns,\n  parts,\n  skipPredicate,\n  lastSkipRequired,\n  lastPatternRequired,\n  matchPart,\n  skipUntilStartsMatching = false,\n}) => {\n  let matched\n  let patternIndex = 0\n  let partIndex = 0\n  let matchIndex = 0\n\n  if (patterns.length === 0 && parts.length === 0) {\n    matched = true\n  } else if (patterns.length === 0 && parts.length) {\n    matched = true\n    matchIndex = parts.length\n  } else if (patterns.length && parts.length === 0) {\n    matched = false\n  } else {\n    matched = true\n\n    while (true) {\n      const pattern = patterns[patternIndex]\n      const part = parts[partIndex]\n      const isSkipPattern = skipPredicate(pattern)\n      const isLastPattern = patternIndex === patterns.length - 1\n      const isLastPart = partIndex === parts.length - 1\n\n      if (isSkipPattern && isLastPart && isLastPattern) {\n        matchIndex += part.length\n        break\n      }\n\n      if (isSkipPattern && isLastPattern && isLastPart === false) {\n        matchIndex += part.length\n        break\n      }\n\n      if (isSkipPattern && isLastPattern === false && isLastPart) {\n        // test next pattern on current part\n        patternIndex++\n        const nextPatternResult = match({\n          patterns: patterns.slice(patternIndex),\n          parts: parts.slice(partIndex),\n          skipPredicate,\n          lastSkipRequired,\n          lastPatternRequired,\n          matchPart,\n        })\n        matched = nextPatternResult.matched\n        patternIndex += nextPatternResult.patternIndex\n        partIndex += nextPatternResult.partIndex\n\n        if (matched && patternIndex === patterns.length - 1) {\n          matchIndex += nextPatternResult.matchIndex\n          break\n        }\n        if (matched && partIndex === parts.length - 1) {\n          matchIndex += nextPatternResult.matchIndex\n          break\n        }\n        if (matched) {\n          matchIndex += nextPatternResult.matchIndex\n          continue\n        }\n\n        // we still increase the matchIndex by the length of the part because\n        // this part has matched even if the full pattern is not satisfied\n        matchIndex += part.length\n        break\n      }\n\n      if (isSkipPattern && isLastPattern === false && isLastPart === false) {\n        // test next pattern on current part\n        patternIndex++\n\n        const skipResult = match({\n          patterns: patterns.slice(patternIndex),\n          parts: parts.slice(partIndex),\n          skipPredicate,\n          lastSkipRequired,\n          lastPatternRequired,\n          matchPart,\n          skipUntilStartsMatching: true,\n        })\n\n        matched = skipResult.matched\n        patternIndex += skipResult.patternIndex\n        partIndex += skipResult.partIndex\n        matchIndex += skipResult.matchIndex\n\n        if (matched && patternIndex === patterns.length - 1) {\n          break\n        }\n        if (matched && partIndex === parts.length - 1) {\n          break\n        }\n        if (matched) {\n          continue\n        }\n        break\n      }\n\n      const partMatch = matchPart(pattern, part)\n      matched = partMatch.matched\n      matchIndex += partMatch.matchIndex\n\n      if (matched && isLastPattern && isLastPart) {\n        break\n      }\n\n      if (matched && isLastPattern && isLastPart === false) {\n        if (lastPatternRequired) {\n          matched = false\n        }\n        break\n      }\n\n      if (matched && isLastPattern === false && isLastPart) {\n        const remainingPatternAreSkip = patterns\n          .slice(patternIndex + 1)\n          .every((pattern) => skipPredicate(pattern))\n\n        if (remainingPatternAreSkip && lastSkipRequired) {\n          matched = false\n          break\n        }\n        if (remainingPatternAreSkip === false) {\n          matched = false\n          break\n        }\n        break\n      }\n\n      if (matched && isLastPattern === false && isLastPart === false) {\n        patternIndex++\n        partIndex++\n        continue\n      }\n\n      if (matched === false && skipUntilStartsMatching && isLastPart === false) {\n        partIndex++ // keep searching for that pattern\n        matchIndex++\n        continue\n      }\n\n      break\n    }\n\n    return {\n      matched,\n      matchIndex,\n      patternIndex,\n      partIndex,\n    }\n  }\n}\n\nconst locationMatch = (pattern, location) => {\n  return match({\n    patterns: pattern.split(\"/\"),\n    parts: location.split(\"/\"),\n    lastPatternRequired: false,\n    lastSkipRequired: true,\n    skipPredicate: (sequencePattern) => sequencePattern === \"**\",\n    matchPart: (sequencePattern, sequencePart) => {\n      return match({\n        patterns: sequencePattern.split(\"\"),\n        parts: sequencePart.split(\"\"),\n        lastPatternRequired: true,\n        lastSkipRequired: false,\n        skipPredicate: (charPattern) => charPattern === \"*\",\n        matchPart: (charPattern, charSource) => {\n          const matched = charPattern === charSource\n          return {\n            matched,\n            patternIndex: 0,\n            partIndex: 0,\n            matchIndex: matched ? 1 : 0,\n          }\n        },\n      })\n    },\n  })\n}\n\nexport const createLocationMeta = ({ mergeMeta = (a, b) => ({ ...a, ...b }) } = {}) => {\n  const patternAndMetaList = []\n\n  const addMetaAtPattern = (pattern, meta = {}) => {\n    const existingPattern = patternAndMetaList.find(\n      (patternAndMeta) => patternAndMeta.pattern === pattern,\n    )\n    if (existingPattern) {\n      existingPattern.meta = mergeMeta(existingPattern.meta, meta)\n    } else {\n      patternAndMetaList.push({\n        pattern,\n        meta,\n      })\n    }\n  }\n\n  const getMetaForLocation = (filename) => {\n    return patternAndMetaList.reduce((previousMeta, { pattern, meta }) => {\n      const { matched } = locationMatch(pattern, filename)\n      return matched ? mergeMeta(previousMeta, meta) : previousMeta\n    }, {})\n  }\n\n  const canContainsMetaMatching = (filename, metaPredicate) => {\n    const matchIndexForFile = filename.split(\"/\").join(\"\").length\n    const partialMatch = patternAndMetaList.some(({ pattern, meta }) => {\n      const { matched, matchIndex } = locationMatch(pattern, filename)\n      return matched === false && matchIndex >= matchIndexForFile && metaPredicate(meta)\n    })\n    if (partialMatch) {\n      return true\n    }\n\n    // no partial match satisfies predicate, does it work on a full match ?\n    const meta = getMetaForLocation(filename)\n    return Boolean(metaPredicate(meta))\n  }\n\n  const toJSON = () => {\n    return patternAndMetaList\n  }\n\n  return {\n    addMetaAtPattern,\n    getMetaForLocation,\n    canContainsMetaMatching,\n    toJSON,\n  }\n}\n","import fs from \"fs\"\n\nconst readDirectory = (dirname) =>\n  new Promise((resolve, reject) => {\n    fs.readdir(dirname, (error, names) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve(names)\n      }\n    })\n  })\n\nconst readStat = (filename) =>\n  new Promise((resolve, reject) => {\n    fs.stat(filename, (error, stat) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve(stat)\n      }\n    })\n  })\n\nconst nothingToDo = {}\n\nexport const forEachFileMatching = (\n  { getMetaForLocation, canContainsMetaMatching },\n  root,\n  metaPredicate,\n  callback,\n) => {\n  const visit = (folderRelativeLocation) => {\n    const folderAbsoluteLocation = folderRelativeLocation\n      ? `${root}/${folderRelativeLocation}`\n      : root\n\n    return readDirectory(folderAbsoluteLocation).then((names) => {\n      return Promise.all(\n        names.map((name) => {\n          const ressourceRelativeLocation = folderRelativeLocation\n            ? `${folderRelativeLocation}/${name}`\n            : name\n          const ressourceAbsoluteLocation = `${root}/${ressourceRelativeLocation}`\n\n          return readStat(ressourceAbsoluteLocation).then((stat) => {\n            if (stat.isDirectory()) {\n              if (canContainsMetaMatching(ressourceRelativeLocation, metaPredicate) === false) {\n                return [nothingToDo]\n              }\n              return visit(ressourceRelativeLocation)\n            }\n\n            const meta = getMetaForLocation(ressourceRelativeLocation)\n            if (metaPredicate(meta)) {\n              return Promise.resolve(\n                callback({\n                  absoluteName: ressourceAbsoluteLocation,\n                  relativeName: ressourceRelativeLocation,\n                  meta,\n                }),\n              ).then((result) => {\n                return [result]\n              })\n            }\n            return [nothingToDo]\n          })\n        }),\n      ).then((results) => {\n        return results.reduce((previous, results) => {\n          return [...previous, ...results]\n        }, [])\n      })\n    })\n  }\n  return visit().then((allResults) => {\n    return allResults.filter((result) => result !== nothingToDo)\n  })\n}\n","import { createLocationMeta } from \"./createLocationMeta.js\"\nimport { forEachFileMatching } from \"./forEachFileMatching.js\"\n\nconst CONFIG_FILE_NAME = \"structure.config.js\"\n\nconst loadMetasForRoot = (root) => {\n  return new Promise((resolve, reject) => {\n    const filename = `${root}/${CONFIG_FILE_NAME}`\n\n    let value\n    let errored = false\n    try {\n      // eslint-disable-nextline no-dynamic-require\n      value = require(filename)\n    } catch (e) {\n      value = e\n      errored = true\n    }\n\n    if (errored) {\n      const error = value\n      if (error && error.code === \"MODULE_NOT_FOUND\") {\n        return reject(new Error(`${filename} not found`))\n      }\n      if (error && error.code === \"SYNTAX_ERROR\") {\n        console.error(`${filename} contains a syntax error`)\n        return reject(error)\n      }\n      if (error && error.code === \"REFERENCE_ERROR\") {\n        console.error(`${filename} contains a reference error`)\n        return reject(error)\n      }\n      return reject(error)\n    }\n\n    const namespace = value\n    const namespaceType = typeof namespace\n    if (namespaceType !== \"object\") {\n      return reject(new TypeError(`${filename} must export an object, got ${namespaceType}`))\n    }\n\n    resolve(namespace.metas || {})\n  })\n}\n\nexport const createRoot = ({ root, getLocationMeta = () => createLocationMeta() }) => {\n  return loadMetasForRoot(root).then((metas) => {\n    const locationMeta = getLocationMeta()\n\n    Object.keys(metas).forEach((metaName) => {\n      const metaPatterns = metas[metaName]\n      Object.keys(metaPatterns).forEach((pattern) => {\n        const metaValue = metaPatterns[pattern]\n        locationMeta.addMetaAtPattern(pattern, { [metaName]: metaValue })\n      })\n    })\n\n    const scopedForEachFileMatching = (predicate, callback) =>\n      forEachFileMatching(locationMeta, root, predicate, callback)\n\n    const listFileMatching = (predicate) =>\n      forEachFileMatching(locationMeta, root, predicate, ({ relativeName }) => relativeName)\n\n    return {\n      ...locationMeta,\n      forEachFileMatching: scopedForEachFileMatching,\n      listFileMatching,\n    }\n  })\n}\n"],"names":["match","patterns","parts","skipPredicate","lastSkipRequired","lastPatternRequired","matchPart","skipUntilStartsMatching","matched","patternIndex","partIndex","matchIndex","length","pattern","part","isSkipPattern","isLastPattern","isLastPart","nextPatternResult","slice","skipResult","partMatch","remainingPatternAreSkip","every","locationMatch","location","split","sequencePattern","sequencePart","charPattern","charSource","createLocationMeta","mergeMeta","a","b","patternAndMetaList","addMetaAtPattern","meta","existingPattern","find","patternAndMeta","push","getMetaForLocation","filename","reduce","previousMeta","canContainsMetaMatching","metaPredicate","matchIndexForFile","join","partialMatch","some","Boolean","toJSON","readDirectory","dirname","Promise","resolve","reject","fs","readdir","error","names","readStat","stat","nothingToDo","forEachFileMatching","root","callback","visit","folderRelativeLocation","folderAbsoluteLocation","then","all","map","name","ressourceRelativeLocation","ressourceAbsoluteLocation","isDirectory","absoluteName","relativeName","result","results","previous","allResults","filter","CONFIG_FILE_NAME","loadMetasForRoot","value","errored","require","e","code","Error","console","namespace","namespaceType","TypeError","metas","createRoot","getLocationMeta","locationMeta","Object","keys","forEach","metaName","metaPatterns","metaValue","scopedForEachFileMatching","predicate","listFileMatching"],"mappings":"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"}